<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyper-interaktiv Projektor Entanglementanemone</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            touch-action: none;
        }
        canvas { 
            display: block; 
            touch-action: none;
        }
        #cameraFeed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
        }
    </style>
</head>
<body>
    <video id="cameraFeed" autoplay playsinline></video>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const noiseGen = new SimplexNoise();

        const tentacleCount = 200;
        const tentacleSegments = 50;
        const tentacles = [];

        const tentacleGroup = new THREE.Group();
        scene.add(tentacleGroup);

        for (let i = 0; i < tentacleCount; i++) {
            const points = [];
            for (let j = 0; j < tentacleSegments; j++) {
                const angle = (i / tentacleCount) * Math.PI * 2;
                const radius = 2 + j * 0.15 + Math.random() * 0.1;
                points.push(new THREE.Vector3(
                    Math.cos(angle) * radius + (Math.random() - 0.5) * 0.5,
                    Math.sin(angle) * radius + (Math.random() - 0.5) * 0.5,
                    j * 0.2 - 5 + (Math.random() - 0.5) * 0.5
                ));
            }
            const tentacleGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const tentacleMaterial = new THREE.LineBasicMaterial({ 
                color: 0xCCCCCC,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });
            const tentacle = new THREE.Line(tentacleGeometry, tentacleMaterial);
            tentacleGroup.add(tentacle);
            tentacles.push(tentacle);
        }

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        camera.position.z = 15;

        let time = 0;
        let motionIntensity = 0;
        let motionDirection = new THREE.Vector2(0, 0);

        const video = document.getElementById('cameraFeed');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let lastImageData;

        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(stream => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                };
            })
            .catch(err => console.error("Fejl ved adgang til kamera:", err));

        function detectMotion() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                if (lastImageData) {
                    let diffX = 0, diffY = 0, totalDiff = 0;
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const i = (y * canvas.width + x) * 4;
                            const diff = Math.abs(imageData.data[i] - lastImageData.data[i]);
                            diffX += diff * (x / canvas.width - 0.5);
                            diffY += diff * (y / canvas.height - 0.5);
                            totalDiff += diff;
                        }
                    }
                    motionIntensity = Math.min(totalDiff / (imageData.data.length / 4) / 50, 1);
                    motionDirection.set(diffX / totalDiff, -diffY / totalDiff);
                }
                
                lastImageData = imageData;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            detectMotion();
            
            tentacles.forEach((tentacle, index) => {
                const positions = tentacle.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const segmentIndex = i / 3;
                    const noiseValue = noiseGen.noise4D(
                        positions[i] * 0.3, 
                        positions[i+1] * 0.3, 
                        positions[i+2] * 0.3, 
                        time * 0.5 + index * 0.1
                    ) * 0.5;

                    const chaosX = Math.sin(time * 3 + index) * 0.2;
                    const chaosY = Math.cos(time * 2.5 + index * 1.5) * 0.2;
                    const chaosZ = Math.sin(time * 2 + index * 0.7) * 0.2;

                    positions[i] += (noiseValue * 0.05 + chaosX) * (segmentIndex / tentacleSegments);
                    positions[i+1] += (noiseValue * 0.05 + chaosY) * (segmentIndex / tentacleSegments);
                    positions[i+2] += (noiseValue * 0.05 + chaosZ) * (segmentIndex / tentacleSegments);

                    // Reagér på bevægelsesretning
                    positions[i] += motionDirection.x * motionIntensity * 0.2 * (segmentIndex / tentacleSegments);
                    positions[i+1] += motionDirection.y * motionIntensity * 0.2 * (segmentIndex / tentacleSegments);

                    // Tilføj bølgeeffekt baseret på bevægelsesintensitet
                    const waveEffect = Math.sin(time * 5 + segmentIndex * 0.5) * motionIntensity * 0.1;
                    positions[i] += waveEffect;
                    positions[i+1] += waveEffect;

                    // Tilføj spiraleffekt baseret på bevægelsesintensitet
                    const spiralAngle = motionIntensity * Math.PI * 2 * (segmentIndex / tentacleSegments);
                    const spiralRadius = motionIntensity * (segmentIndex / tentacleSegments) * 0.5;
                    positions[i] += Math.cos(spiralAngle) * spiralRadius;
                    positions[i+1] += Math.sin(spiralAngle) * spiralRadius;
                }
                tentacle.geometry.attributes.position.needsUpdate = true;

                // Dynamisk opacitet baseret på bevægelse
                tentacle.material.opacity = 0.3 + motionIntensity * 0.7;
            });

            // Rotér hele anemonen baseret på bevægelsesretning
            tentacleGroup.rotation.x += motionDirection.y * motionIntensity * 0.05;
            tentacleGroup.rotation.y += motionDirection.x * motionIntensity * 0.05;

            // Pulserende effekt baseret på bevægelsesintensitet
            const pulseFactor = 1 + Math.sin(time * 3) * 0.1 + motionIntensity * 0.3;
            tentacleGroup.scale.set(pulseFactor, pulseFactor, pulseFactor);

            // Kamerabevægelse baseret på motion
            camera.position.x += (motionDirection.x * motionIntensity - camera.position.x) * 0.05;
            camera.position.y += (motionDirection.y * motionIntensity - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        animate();

        // Fuld skærm funktionalitet
        let lastTapTime = 0;

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function handleTap(event) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;
            if (tapLength < 300 && tapLength > 0) {
                toggleFullScreen();
                event.preventDefault();
            }
            lastTapTime = currentTime;
        }

        document.addEventListener('touchend', handleTap);
        document.addEventListener('mouseup', handleTap);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
